#lang racket

(require test-engine/racket-tests)


(define (make-inc x)
  (lambda (y) (+ x y)))

(define inc-by-5 (make-inc 5))
;(inc-by-5 100)

(define inc-by-10 (make-inc 10))
;(inc-by-10 100)

;(define (plus-x y)
;  (+ x y))

(define x 100)
(define (plus-x y)
  (+ x y))

;(plus-x 10)

;(let ([x 200])
;  (plus-x 10))

;(set! x 200)
;(plus-x 10)


(define counter
  (let ([count 0])
    (lambda ()
      (set! count (+ count 1))
      count)))

;(counter)
;(counter)
;(counter)

(define make-counter
  (let ([global-count 0])
    (lambda ()
      (let ([local-count 0])
        (lambda ()
          (set! global-count (+ global-count 1))
          (set! local-count (+ local-count 1))
          (cons global-count local-count))))))

(define counter1 (make-counter))
(define counter2 (make-counter))

;(counter1)
;(counter1)
;(counter2)
;(counter2)
;(counter1)

;;;;;;;;;;;;;;;;;;;;;;;  CONTINUATION PASSING STYLE ;;;;;;;;;;;;;;;;;;;;;

; (my-length xs) -> integer?
; xs: list?
; return the number of elements in xs
(define (my-length-rec xs)   ; return length[xs]
  (if (empty? xs)
      0
      (+ 1 (my-length-rec (rest xs)))))

(check-expect (my-length-rec '()) 0)
(check-expect (my-length-rec '(42)) 1)
(check-expect (my-length-rec '(1 2 (3 6) 4 5)) 5)

; [length '[1 2]]             <--- new stack frame
; [+ 1 [length '[2]]]         <--- new stack frame
; [+ 1 [+ 1 [length '[]]]]    <--- new stack frame
; [+ 1 [+ 1 0]]               <--- pop
; [+ 1 1]                     <--- pop
; 2                           <--- pop

(define (my-length-tail xs)   ; return length[xs]
  (local
    [(define (my-len-t xs acc)  ; return length[xs] + acc
       (if (empty? xs)
           acc
           (my-len-t (rest xs) (+ acc 1))))]
    (my-len-t xs 0)))

(check-expect (my-length-tail '()) 0)
(check-expect (my-length-tail '(42)) 1)
(check-expect (my-length-tail '(1 2 (3 6) 4 5)) 5)

; [length-tail '[1 2]]      <--- new stack frame
; [len-t '[1 2] 0]          <--- new stack frame
; [len-t '[2] 1]
; [len-t '[] 2]             <--- pop
; 2                         <--- pop
; Only need one extra for the call to helper! Can reuse space for the rest.


(define (my-length-cps xs)   ; return length[xs]
  (local
    [(define (len-cps xs k)  ; return ?
       42)]
    (len-cps 42 42)))

(check-expect (my-length-cps '()) 0)
(check-expect (my-length-cps '(42)) 1)
(check-expect (my-length-cps '(1 2 (3 6) 4 5)) 5)

; [length-cps '[1 2]]



; Let's write a tail recursive version of foldr.

(define (foldr-tail-first-try f id xs)
  (local
    [(define (foldr-tail xs acc)
       42)]
    (foldr-tail 42 42)))

(check-expect (foldr-tail-first-try * 1 '(1 2 3))
              6)
(check-within (foldr-tail-first-try max -inf.0 '(9 20 5 6 78 100 10000))
              10000.0
              0.01)
(check-expect (foldr-tail-first-try cons '() '(1 2 3)) '(1 2 3))
(check-expect (foldr-tail-first-try list '() '(1 2 3)) '(1 (2 (3 ()))))


(define (foldr-tail f id xs)  ; returns [foldr f id xs]
  (local
    [(define (foldr-cps xs k)
       42)]
    (foldr-cps 42 42)))

(check-expect (foldr-tail * 1 '(1 2 3))
              6)
(check-within (foldr-tail max -inf.0 '(9 20 5 6 78 100 10000))
              10000.0
              0.01)
(check-expect (foldr-tail cons '() '(1 2 3)) '(1 2 3))
(check-expect (foldr-tail list '() '(1 2 3)) '(1 (2 (3 ()))))

(test)